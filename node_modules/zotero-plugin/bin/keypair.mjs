#!/usr/bin/env node

// bin/keypair.ts
import { Command } from "commander";
import crypto2 from "crypto";
import { stat, writeFile } from "fs/promises";
import { resolve } from "path";
import prompts from "prompts";

// bin/crypto.ts
import crypto from "crypto";
function encrypt(plaintext, passphrase) {
  const salt = crypto.randomBytes(16);
  const iterations = 1e5;
  const keyLength = 32;
  const algorithm = "aes-256-gcm";
  const key = crypto.pbkdf2Sync(passphrase, salt, iterations, keyLength, "sha256");
  const iv = crypto.randomBytes(12);
  const cipher = crypto.createCipheriv(algorithm, key, iv);
  let ciphertext = cipher.update(plaintext, "utf8", "base64");
  ciphertext += cipher.final("base64");
  const tag = cipher.getAuthTag();
  return {
    ciphertext,
    iv: iv.toString("base64"),
    tag: tag.toString("base64"),
    salt: salt.toString("base64"),
    iterations,
    keyLength,
    algorithm
  };
}

// bin/keypair.ts
import { config as dotenvConfig } from "dotenv";
dotenvConfig({ quiet: true, override: true });
var program = new Command();
program.description("A script to generate and store an RSA key pair in an encrypted file.").option("-p, --public <path>", "Path for the public key .pem file", "public.pem").option("--private <path>", "Path for the encrypted private key .pem.json file", "private.pem.json").option("-r, --replace", "Replace existing files", false).parse(process.argv);
var options = program.opts();
async function main() {
  try {
    const publicKeyPath = resolve(options.public);
    const encryptedKeyPath = resolve(options.private);
    if (!publicKeyPath.endsWith(".pem")) {
      console.error("Public key file must have a .pem extension.");
      process.exit(1);
    }
    if (!encryptedKeyPath.endsWith(".pem.json")) {
      console.error("Encrypted key file must have a .pem.json extension.");
      process.exit(1);
    }
    const fileExists = async (path) => {
      try {
        await stat(path);
        return true;
      } catch (e) {
        if (e.code === "ENOENT") {
          return false;
        }
        throw e;
      }
    };
    if (await fileExists(publicKeyPath) && !options.replace) {
      console.error(`Will not overwrite existing public key file: ${publicKeyPath}`);
      process.exit(1);
    }
    if (await fileExists(encryptedKeyPath) && !options.replace) {
      console.error(`Will not overwrite existing encrypted key file: ${encryptedKeyPath}`);
      process.exit(1);
    }
    const { privateKey, publicKey } = crypto2.generateKeyPairSync("rsa", {
      modulusLength: 2048,
      publicKeyEncoding: {
        type: "spki",
        format: "pem"
      },
      privateKeyEncoding: {
        type: "pkcs8",
        format: "pem"
      }
    });
    const { passphrase } = await prompts({
      type: "password",
      name: "passphrase",
      message: "Enter a passphrase to encrypt your private key:"
    });
    if (!passphrase) {
      console.error("Passphrase is required for encryption.");
      process.exit(1);
    }
    await writeFile(encryptedKeyPath, JSON.stringify(encrypt(privateKey, passphrase), null, 2));
    console.log(`Encrypted private key saved to: ${encryptedKeyPath}`);
    await writeFile(publicKeyPath, publicKey);
    console.log(`Public key saved to: ${publicKeyPath}`);
  } catch (error) {
    throw error;
  }
}
main();
