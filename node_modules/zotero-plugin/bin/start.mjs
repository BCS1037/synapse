#!/usr/bin/env node

// bin/start.ts
import { exec, spawn } from "child_process";
import { program } from "commander";
import fs from "fs";
import { globSync } from "glob";
import ini from "ini";
import os from "os";
import path from "path";
program.option("-b, --beta", "start beta");
program.parse(process.argv);
var options = program.opts();
var Config = class {
  profile;
  zotero;
  plugin;
  preference;
  windows;
  constructor() {
    const config_file = "zotero-plugin.ini";
    if (!fs.existsSync(config_file)) {
      throw new Error(`Cannot find ${config_file}`);
    }
    const config2 = ini.parse(fs.readFileSync(config_file, "utf-8"));
    this.profile = {
      path: this.expandUserPath(config2.profile?.path || ""),
      name: config2.profile?.name
    };
    if (!this.profile.path) throw new Error("no profile path");
    this.zotero = {
      path: config2.zotero?.[options.beta ? "beta" : "path"],
      log: config2.zotero?.log,
      db: config2.zotero?.db
    };
    const beta = options.beta ? "-beta" : "";
    if (this.zotero.path) {
      this.zotero.path = this.expandUserPath(this.zotero.path);
    } else {
      switch (os.platform()) {
        case "darwin":
          this.zotero.path = `/Applications/Zotero${beta}.app/Contents/MacOS/zotero`;
          break;
        case "linux":
          this.zotero.path = `/usr/lib/zotero${beta}/zotero`;
          break;
        case "win32":
          this.zotero.path = `C:/Program Files (x86)/Zotero${beta}/Zotero.exe`;
          break;
        default:
          throw new Error(`${os.platform()} not supported`);
      }
    }
    this.windows = os.platform() === "win32";
    if (this.zotero.log) this.zotero.log = this.expandUserPath(this.zotero.log);
    const source = config2.plugin?.source || this.find_source();
    if (!source) {
      throw new Error("Plugin source not found.");
    }
    this.plugin = {
      source: path.resolve(source),
      build: config2.plugin?.build || "npm run build"
    };
    this.preference = {};
    if (config2.preferences) {
      for (const key in config2.preferences) {
        if (Object.prototype.hasOwnProperty.call(config2.preferences, key)) {
          this.preference[key] = this.pref_value(config2.preferences[key]);
        }
      }
    }
    this.preference["extensions.autoDisableScopes"] = 0;
    this.preference["extensions.enableScopes"] = 15;
    this.preference["extensions.startupScanScopes"] = 15;
    this.preference["extensions.zotero.debug.log"] = true;
    this.preference["extensions.lastAppBuildId"] = null;
    this.preference["extensions.lastAppVersion"] = null;
  }
  expandUserPath(p) {
    return p.startsWith("~") ? path.join(os.homedir(), p.slice(1)) : p;
  }
  find_source() {
    const rdfs = globSync(path.join("*", "manifest.json"));
    if (rdfs.length > 0) {
      return path.dirname(rdfs[0]);
    }
    if (fs.existsSync("build")) {
      return "build";
    }
    return false;
  }
  pref_value(v) {
    if (v === "true") return true;
    if (v === "false") return false;
    if (v === "null") return null;
    try {
      return JSON.parse(v);
    } catch (e) {
      return v;
    }
  }
};
var config = new Config();
function patch_prefs(prefs, add_config) {
  const prefs_path = path.join(config.profile.path, `${prefs}.js`);
  if (!fs.existsSync(prefs_path)) return;
  const lines = fs.readFileSync(prefs_path, "utf-8").split("\n");
  const new_lines = [];
  for (const line of lines) {
    const match = line.match(/user_pref\("(.+?)"/);
    if (!match || !(match[1] in config.preference)) {
      new_lines.push(line);
    }
  }
  if (add_config) {
    for (const [key, value] of Object.entries(config.preference)) {
      if (value !== null) {
        new_lines.push(`user_pref(${JSON.stringify(key)}, ${JSON.stringify(value)});`);
      }
    }
  }
  fs.writeFileSync(prefs_path, new_lines.join("\n"));
}
async function main() {
  try {
    patch_prefs("prefs", false);
    patch_prefs("user", true);
    if (config.plugin.build) {
      await new Promise((resolve, reject) => {
        exec(config.plugin.build, (error, stdout, stderr) => {
          if (error) {
            reject(error);
          } else {
            resolve();
          }
        });
      });
    }
    if (config.zotero.db) {
      fs.copyFileSync(config.zotero.db, path.join(config.profile.path, "zotero", "zotero.sqlite"));
    }
    const manifest = JSON.parse(fs.readFileSync(path.join(config.plugin.source, "manifest.json"), "utf-8"));
    const addonId = manifest?.applications?.zotero?.id;
    if (!addonId) {
      throw new Error("Could not find addon ID in manifest.json");
    }
    const plugin_path = path.join(config.profile.path, "extensions", addonId);
    const sources = config.plugin.source;
    const proxyPath = config.windows ? sources.replace(/\\/g, "\\\\") : sources;
    console.log("Writing addon source path to proxy file");
    console.log("Source path:", sources);
    console.log("Proxy file path:", plugin_path);
    fs.writeFileSync(plugin_path, proxyPath);
    const cmd = [
      config.zotero.path,
      "-purgecaches",
      "-P",
      config.profile.name,
      config.windows ? "-ZoteroDebug" : "-ZoteroDebugText",
      "-jsconsole",
      "-datadir",
      "profile"
    ];
    let child;
    if (config.zotero.log) {
      const log = fs.openSync(config.zotero.log, "w");
      child = spawn(cmd[0], cmd.slice(1), {
        detached: true,
        stdio: ["ignore", log, "ignore"]
      });
    } else {
      child = spawn(cmd[0], cmd.slice(1));
    }
    child.unref();
  } catch (err) {
    console.error(err);
  }
}
main();
