#!/usr/bin/env node

// bin/release.ts
import "dotenv/config";
import { execSync as execSync2 } from "child_process";
import { program } from "commander";
import * as fs2 from "fs";
import moment from "moment";
import * as path2 from "path";
import uriTemplate from "uri-templates";

// continuous-integration.ts
import * as child_process from "child_process";
var ContinuousIntegrationSingleton = class {
  service = "";
  build_number;
  tag = "";
  commit_message = "";
  branch = "";
  pull_request = false;
  issue = "";
  constructor() {
    for (const [id, name] of Object.entries({ CIRCLECI: "Circle", TRAVIS: "Travis", SEMAPHORE: "Semaphore", GITHUB_ACTIONS: "GitHub" })) {
      if (process.env[id] === "true") this.service = name;
    }
    switch (this.service) {
      case "Circle":
        this.build_number = this.parseInt(process.env.CIRCLE_BUILD_NUM);
        try {
          this.tag = child_process.execSync(`git describe --exact-match ${process.env.CIRCLE_SHA1}`, { stdio: "pipe" }).toString().trim();
        } catch (err) {
          this.tag = null;
        }
        this.commit_message = child_process.execSync(`git log --format=%B -n 1 ${process.env.CIRCLE_SHA1}`).toString().trim();
        this.branch = process.env.CIRCLE_BRANCH;
        this.pull_request = !!process.env.CIRCLE_PULL_REQUEST;
        break;
      case "GitHub":
        this.build_number = this.parseInt(process.env.GITHUB_RUN_NUMBER);
        this.commit_message = child_process.execSync(`git log --format=%B -n 1 ${process.env.GITHUB_SHA}`).toString().trim();
        this.pull_request = process.env.GITHUB_EVENT_NAME.startsWith("pull-request");
        if (process.env.GITHUB_HEAD_REF) {
          this.branch = process.env.GITHUB_HEAD_REF.split("/").pop();
        } else if (process.env.GITHUB_REF.startsWith("refs/tags/")) {
          this.tag = process.env.GITHUB_REF.split("/").pop();
        } else if (process.env.GITHUB_REF.startsWith("refs/heads/")) {
          this.branch = process.env.GITHUB_REF.split("/").pop();
        }
        this.branch = this.branch || "";
        this.issue = this.branch.match(/^gh-([0-9]+)$/)?.[1] || "";
        break;
      default:
        if (process.env.CI === "true") throw new Error(`Unexpected CI service ${this.service}`);
    }
  }
  parseInt(n) {
    if (typeof n === "number") return n;
    const int = parseInt(n);
    if (isNaN(int)) throw new Error(`${n} is not an integer`);
    return int;
  }
};
var ContinuousIntegration = new ContinuousIntegrationSingleton();

// root.ts
var root_default = process.cwd();

// bin/release.ts
import { Octokit } from "@octokit/rest";

// version.ts
import * as fs from "fs";
import * as os from "os";
import * as path from "path";
var version = null;
function load(vpath) {
  return JSON.parse(fs.readFileSync(vpath, "utf-8")).version;
}
var version_json = path.join(root_default, "gen/version.json");
if (fs.existsSync(version_json)) {
  version = load(version_json);
} else {
  console.log("writing version");
  version = load(path.join(root_default, "package.json"));
  if (ContinuousIntegration.service && !ContinuousIntegration.tag) {
    const issue = ContinuousIntegration.issue && process.env.VERSION_WITH_ISSUE !== "false" ? `.${ContinuousIntegration.issue}` : "";
    version = `${version}${issue}.${ContinuousIntegration.build_number}`;
  } else if (!ContinuousIntegration.service) {
    version = `${version}.${os.userInfo().username}.${os.hostname()}`;
  }
  if (!fs.existsSync(path.dirname(version_json))) fs.mkdirSync(path.dirname(version_json));
  fs.writeFileSync(version_json, JSON.stringify({ version }));
}
var version_default = version;

// bin/release.ts
process.on("unhandledRejection", (up) => {
  throw up;
});
program.option("-r, --release-message <value>", "add message to github release").option("-x, --xpi <value>", "xpi filename template", "{name}-{version}.xpi").option("-d, --dry-run", "dry run", !ContinuousIntegration.service).option("-p, --pre-release", "release is a pre-release").option("-t, --tag <value>", "tag for release", ContinuousIntegration.tag).parse(process.argv);
var options = program.opts();
if (options.tag && options.tag !== ContinuousIntegration.tag) {
  console.log("dry-run: tag specified manually, switching to dry-run mode");
  options.dryRun = true;
}
if (options.releaseMessage?.startsWith("@")) options.releaseMessage = fs2.readFileSync(options.releaseMessage.substring(1), "utf-8");
var octokit = new Octokit({ auth: `token ${process.env.GITHUB_TOKEN}` });
var pkg = JSON.parse(fs2.readFileSync(path2.join(root_default, "package.json"), "utf-8"));
var [, owner, repo] = pkg.repository.url.match(/:\/\/github.com\/([^/]+)\/([^.]+)\.git$/);
var xpi = uriTemplate(options.xpi).fill({ ...pkg, version: version_default });
var EXPIRE_BUILDS = moment().subtract(7, "days").toDate().toISOString();
function bail(msg, status = 1) {
  console.log(msg);
  process.exit(status);
}
if (options.dryRun) {
  console.log("Not running on CI service, switching to dry-run mode");
  ContinuousIntegration.branch = execSync2("git rev-parse --abbrev-ref HEAD", { encoding: "utf8" }).trim();
}
function report(msg) {
  console.log(`${options.dryRun ? "dry-run: " : ""}${msg}`);
}
if (ContinuousIntegration.pull_request) bail("Not releasing pull requests", 0);
if (options.tag) {
  if (`v${pkg.version}` !== options.tag) bail(`Building tag ${options.tag}, but package version is ${pkg.version}`);
  const releaseBranches = ["main", "master"].concat(pkg.xpi.releaseBranches || []);
  if (ContinuousIntegration.branch && !releaseBranches.includes(ContinuousIntegration.branch)) bail(`Building tag ${options.tag}, but branch is ${ContinuousIntegration.branch}`);
}
var tags = /* @__PURE__ */ new Set();
for (let regex = /(?:^|\s)(?:#)([a-zA-Z\d]+)/gm, tag; tag = regex.exec(ContinuousIntegration.commit_message); ) {
  tags.add(tag[1]);
}
if (tags.has("norelease")) bail(`Not releasing on ${ContinuousIntegration.branch || "default branch"} because of 'norelease' tag`, 0);
var issues = new Set(Array.from(tags).map(parseInt).filter((tag) => !isNaN(tag)));
if (/^((issue|gh)-)?[0-9]+(-[a-z]+)?$/i.exec(ContinuousIntegration.branch)) {
  issues.add(parseInt(ContinuousIntegration.branch.replace(/[^0-9]/g, "")));
}
async function announce(issue_number, release) {
  if (tags.has("noannounce")) return;
  const issue = (await octokit.issues.get({ owner, repo, issue_number })).data;
  if (issue.locked || issue.state !== "open") return;
  let build;
  let reason = "";
  if (options.tag) {
    build = `${options.preRelease ? "pre-" : ""}release ${ContinuousIntegration.tag}`;
  } else {
    build = `test build ${version_default}`;
  }
  const link = `[${build}](https://github.com/${owner}/${repo}/releases/download/${release.data.tag_name}/${pkg.name}-${version_default}.xpi)`;
  if (!options.tag) {
    reason = ` (${JSON.stringify(ContinuousIntegration.commit_message)})`;
    reason += [
      "",
      `Install in Zotero by downloading ${link}, opening the Zotero "Tools" menu, selecting "Add-ons", open the gear menu in the top right, and select "Install Add-on From File...".`,
      "Please test this build and report back whether it fixes the issue, and if not, what the remaining problem is. In the latter case, please also send a new log."
    ].join("\n\n");
  }
  const body = `:robot: this is your friendly neighborhood build bot announcing ${link}${reason}`;
  report(body);
  if (options.dryRun) return;
  try {
    await octokit.issues.createComment({ owner, repo, issue_number, body });
  } catch (error) {
    report(`Failed to announce '${build}: ${reason}' on ${issue_number}`);
  }
  if (process.env.GITHUB_ENV) fs2.appendFileSync(process.env.GITHUB_ENV, `XPI_RELEASED=${issue_number}
`);
}
async function uploadAsset(release, asset, contentType) {
  report(`uploading ${path2.basename(asset)} to ${release.data.tag_name}`);
  if (options.dryRun) return;
  const name = path2.basename(asset);
  const exists = (await octokit.repos.listReleaseAssets({ owner, repo, release_id: release.data.id })).data.find((a) => a.name === name);
  if (exists) {
    if (release.data.tag_name === "builds") {
      await octokit.repos.deleteReleaseAsset({ owner, repo, asset_id: exists.id });
    } else {
      bail(`failed to upload ${path2.basename(asset)} to ${release.data.html_url}: asset exists`);
    }
  }
  try {
    await octokit.repos.uploadReleaseAsset({
      owner,
      repo,
      url: release.data.upload_url,
      release_id: release.data.id,
      data: fs2.readFileSync(asset),
      // TODO: what is going on here octokit?!
      headers: {
        "content-type": contentType,
        "content-length": fs2.statSync(asset).size
      },
      name
    });
  } catch (err) {
    bail(`failed to upload ${path2.basename(asset)} to ${release.data.html_url}: ${err}`);
  }
}
async function getRelease(tag, prerelease) {
  try {
    return await octokit.repos.getReleaseByTag({ owner, repo, tag });
  } catch {
    try {
      return await octokit.repos.createRelease({ owner, repo, tag_name: tag, prerelease });
    } catch (err) {
      bail(`Could not get release ${tag}: ${err}`);
      return null;
    }
  }
}
async function update_rdf(releases_tag) {
  const release = await getRelease(releases_tag, false);
  const assets = (await octokit.repos.listReleaseAssets({ owner, repo, release_id: release.data.id })).data;
  const updates = {
    "updates.json": "application/json"
  };
  for (const asset of assets) {
    if (asset.name in updates && updates[asset.name]) {
      report(`removing ${asset.name} from ${release.data.tag_name}`);
      if (options.dryRun) {
        report(`update ${asset.name}`);
      } else {
        await octokit.repos.deleteReleaseAsset({ owner, repo, asset_id: asset.id });
      }
    }
  }
  for (const [pointer, mimetype] of Object.entries(updates)) {
    if (mimetype) await uploadAsset(release, path2.join(root_default, `gen/${pointer}`), mimetype);
  }
}
async function main() {
  if (process.env.NIGHTLY === "true") return;
  if (ContinuousIntegration.branch === "l10n_master") {
    for (const issue of (await octokit.issues.listForRepo({ owner, repo, state: "open", labels: "translation" })).data) {
      issues.add(issue.number);
    }
  }
  let release;
  if (options.tag) {
    try {
      await octokit.repos.getReleaseByTag({ owner, repo, tag: options.tag });
      if (!options.dryRun) bail(`release ${options.tag} exists, bailing`);
    } catch (err) {
    }
    if (options.dryRun) {
      report(`create release ${options.tag}`);
      report(`upload asset ${xpi}`);
    } else {
      report(`uploading ${xpi} to new release ${ContinuousIntegration.tag}`);
      release = await octokit.repos.createRelease({ owner, repo, tag_name: ContinuousIntegration.tag, prerelease: !!options.preRelease, body: options.releaseMessage || "" });
      await uploadAsset(release, path2.join(root_default, `xpi/${xpi}`), "application/vnd.zotero.plugin");
    }
    await update_rdf(pkg.xpi.releaseURL.split("/").filter((name) => name).reverse()[0]);
  } else if (issues.size) {
    release = await getRelease("builds", true);
    for (const asset of release.data.assets || []) {
      if (asset.name.endsWith(".xpi") && asset.created_at < EXPIRE_BUILDS) {
        report(`deleting ${asset.name}`);
        if (options.dryRun) {
          report(`delete asset ${asset.name}`);
        } else {
          await octokit.repos.deleteReleaseAsset({ owner, repo, asset_id: asset.id });
        }
      }
    }
    await uploadAsset(release, path2.join(root_default, `xpi/${xpi}`), "application/vnd.zotero.plugin");
  }
  if (process.env.VERBOSE) console.log({ tag: ContinuousIntegration.tag, issues, release, tags });
  for (const issue of Array.from(issues)) {
    await announce(issue, release);
  }
}
main().catch((err) => console.log(err));
