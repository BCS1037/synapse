#!/usr/bin/env node

// bin/zipup.ts
import archiver from "archiver";
import * as fs2 from "fs";
import * as path2 from "path";

// root.ts
var root_default = process.cwd();

// version.ts
import * as fs from "fs";
import * as os from "os";
import * as path from "path";

// continuous-integration.ts
import * as child_process from "child_process";
var ContinuousIntegrationSingleton = class {
  service = "";
  build_number;
  tag = "";
  commit_message = "";
  branch = "";
  pull_request = false;
  issue = "";
  constructor() {
    for (const [id, name] of Object.entries({ CIRCLECI: "Circle", TRAVIS: "Travis", SEMAPHORE: "Semaphore", GITHUB_ACTIONS: "GitHub" })) {
      if (process.env[id] === "true") this.service = name;
    }
    switch (this.service) {
      case "Circle":
        this.build_number = this.parseInt(process.env.CIRCLE_BUILD_NUM);
        try {
          this.tag = child_process.execSync(`git describe --exact-match ${process.env.CIRCLE_SHA1}`, { stdio: "pipe" }).toString().trim();
        } catch (err) {
          this.tag = null;
        }
        this.commit_message = child_process.execSync(`git log --format=%B -n 1 ${process.env.CIRCLE_SHA1}`).toString().trim();
        this.branch = process.env.CIRCLE_BRANCH;
        this.pull_request = !!process.env.CIRCLE_PULL_REQUEST;
        break;
      case "GitHub":
        this.build_number = this.parseInt(process.env.GITHUB_RUN_NUMBER);
        this.commit_message = child_process.execSync(`git log --format=%B -n 1 ${process.env.GITHUB_SHA}`).toString().trim();
        this.pull_request = process.env.GITHUB_EVENT_NAME.startsWith("pull-request");
        if (process.env.GITHUB_HEAD_REF) {
          this.branch = process.env.GITHUB_HEAD_REF.split("/").pop();
        } else if (process.env.GITHUB_REF.startsWith("refs/tags/")) {
          this.tag = process.env.GITHUB_REF.split("/").pop();
        } else if (process.env.GITHUB_REF.startsWith("refs/heads/")) {
          this.branch = process.env.GITHUB_REF.split("/").pop();
        }
        this.branch = this.branch || "";
        this.issue = this.branch.match(/^gh-([0-9]+)$/)?.[1] || "";
        break;
      default:
        if (process.env.CI === "true") throw new Error(`Unexpected CI service ${this.service}`);
    }
  }
  parseInt(n) {
    if (typeof n === "number") return n;
    const int = parseInt(n);
    if (isNaN(int)) throw new Error(`${n} is not an integer`);
    return int;
  }
};
var ContinuousIntegration = new ContinuousIntegrationSingleton();

// version.ts
var version = null;
function load(vpath) {
  return JSON.parse(fs.readFileSync(vpath, "utf-8")).version;
}
var version_json = path.join(root_default, "gen/version.json");
if (fs.existsSync(version_json)) {
  version = load(version_json);
} else {
  console.log("writing version");
  version = load(path.join(root_default, "package.json"));
  if (ContinuousIntegration.service && !ContinuousIntegration.tag) {
    const issue = ContinuousIntegration.issue && process.env.VERSION_WITH_ISSUE !== "false" ? `.${ContinuousIntegration.issue}` : "";
    version = `${version}${issue}.${ContinuousIntegration.build_number}`;
  } else if (!ContinuousIntegration.service) {
    version = `${version}.${os.userInfo().username}.${os.hostname()}`;
  }
  if (!fs.existsSync(path.dirname(version_json))) fs.mkdirSync(path.dirname(version_json));
  fs.writeFileSync(version_json, JSON.stringify({ version }));
}
var version_default = version;

// bin/zipup.ts
var [, , source, target] = process.argv;
var xpi = path2.join(root_default, "xpi", `${target}-${version_default}.xpi`);
console.log(`creating ${xpi}`);
if (fs2.existsSync(xpi)) fs2.unlinkSync(xpi);
if (!fs2.existsSync(path2.dirname(xpi))) fs2.mkdirSync(path2.dirname(xpi));
async function main() {
  await new Promise((resolve, reject) => {
    const xpi2 = path2.join(root_default, "xpi", `${target}-${version_default}.xpi`);
    const output = fs2.createWriteStream(xpi2);
    const archive = archiver("zip", { zlib: { level: 9 } });
    output.on("close", () => {
      console.log(archive.pointer() + " total bytes");
      console.log("Archiver has been finalized and the output file descriptor has closed.");
      resolve();
    });
    archive.on("warning", (err) => {
      if (err.code === "ENOENT") {
        console.warn(err.message);
      } else {
        console.error(err);
      }
    });
    archive.on("error", (err) => {
      reject(err);
    });
    archive.pipe(output);
    archive.directory(`${root_default}/${source}`, false);
    archive.finalize();
  });
}
main().catch((err) => {
  console.log(err);
  process.exit(1);
});
