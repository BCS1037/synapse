"use strict";
/* eslint-disable no-magic-numbers */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DebugLog = exports.Bundler = void 0;
const tslib_1 = require("tslib");
Components.utils.importGlobalProperties(['FormData']);
const pkg = require('./package.json');
const UZip = tslib_1.__importStar(require("uzip"));
class Bundler {
    key;
    #refs = false;
    IV_LENGTH = 12;
    #symmetric;
    #pubkey;
    #crypto;
    #subtle;
    #files = {};
    #encoder = new TextEncoder();
    constructor(pubkey) {
        this.key = Zotero.Utilities.generateObjectKey();
        this.#pubkey = pubkey;
        this.#crypto = Zotero.getMainWindow().crypto;
        this.#subtle = this.#crypto.subtle;
    }
    async add(path, data, refs = false) {
        this.#refs = this.#refs || refs;
        const encoded = this.#encoder.encode(data);
        if (this.#pubkey) {
            if (!this.#symmetric) {
                this.#symmetric = await this.#subtle.generateKey({ name: 'AES-GCM', length: 256 }, true, ['encrypt', 'decrypt']);
                const base64Pem = this.#pubkey
                    .replace('-----BEGIN PUBLIC KEY-----', '')
                    .replace('-----END PUBLIC KEY-----', '')
                    .replace(/\s/g, '');
                const keyBuffer = Uint8Array.from(atob(base64Pem), c => c.charCodeAt(0)).buffer;
                const publicKey = await this.#subtle.importKey('spki', keyBuffer, { name: 'RSA-OAEP', hash: 'SHA-256' }, true, ['encrypt']);
                const exportedKey = await this.#subtle.exportKey('raw', this.#symmetric);
                this.#files[`${this.key}/${this.key}.key`] = new Uint8Array(await this.#subtle.encrypt({ name: 'RSA-OAEP' }, publicKey, exportedKey));
            }
            const iv = this.#crypto.getRandomValues(new Uint8Array(this.IV_LENGTH));
            const encryptedData = await this.#subtle.encrypt({ name: 'AES-GCM', iv: iv }, this.#symmetric, encoded);
            this.#files[`${this.key}/${path}.iv`] = iv;
            this.#files[`${this.key}/${path}.enc`] = new Uint8Array(encryptedData);
        }
        else {
            this.#files[`${this.key}/${path}`] = encoded;
        }
    }
    get zip() {
        return UZip.encode(this.#files);
    }
    get name() {
        return `${this.key}.zip`;
    }
    id(remote) {
        return `${this.key}-${remote}${this.#refs ? '.refs' : ''}${this.#pubkey ? '.enc' : ''}`;
    }
    formData(expire = 7) {
        const blob = new Blob([this.zip], { type: 'application/zip' });
        const formData = new FormData();
        formData.append('file', blob, this.name);
        formData.append('expire', `${expire * 24}`);
        return formData;
    }
}
exports.Bundler = Bundler;
const zotero_prefs_root = 'extensions.zotero.';
class DebugLogSender {
    id = {
        menu: 'debug-log-sender-menu',
        menupopup: 'debug-log-sender-menupopup',
        menuitem: 'debug-log-sender',
    };
    debugEnabledAtStart = typeof Zotero !== 'undefined'
        ? (Zotero.Prefs.get('debug.store') || Zotero.Debug.enabled)
        : null;
    element(name, attrs = {}) {
        const doc = Zotero.getMainWindow().document;
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call
        const elt = doc[Zotero.platformMajorVersion >= 102 ? 'createXULElement' : 'createElement'](name);
        for (const [k, v] of Object.entries(attrs)) {
            elt.setAttribute(k, v);
        }
        return elt;
    }
    register(plugin, preferences = [], pubkey = '') {
        const label = 'Send plugin debug log';
        const doc = Zotero.getMainWindow()?.document;
        if (doc) {
            let menupopup = doc.querySelector(`#${this.id.menupopup}`);
            if (menupopup) {
                menupopup.setAttribute('label', label);
            }
            else {
                menupopup = doc.querySelector('menupopup#menu_HelpPopup')
                    .appendChild(this.element('menu', { id: this.id.menu, label }))
                    .appendChild(this.element('menupopup', { id: this.id.menupopup }));
            }
            doc.querySelector(`.${this.id.menuitem}[label=${JSON.stringify(plugin)}]`)?.remove();
            const menuitem = menupopup.appendChild(this.element('menuitem', {
                label: plugin,
                class: this.id.menuitem,
                'data-preferences': JSON.stringify(preferences || []),
                'data-pubkey': pubkey,
            }));
            menuitem.addEventListener('command', event => this.send(event.currentTarget));
        }
    }
    unregister(plugin) {
        const doc = Zotero.getMainWindow()?.document;
        if (doc) {
            doc.querySelector(`.debug-log-sender[label=${JSON.stringify(plugin)}]`)?.remove();
            const menupopup = doc.querySelector('#debug-log-sender-menupopup');
            if (menupopup && !menupopup.children.length)
                doc.querySelector('#debug-log-sender-menu')?.remove();
        }
    }
    send(target) {
        const elt = target;
        const plugin = elt.getAttribute('label');
        const preferences = JSON.parse(elt.getAttribute('data-preferences'));
        const pubkey = elt.getAttribute('data-pubkey');
        this.sendAsync(plugin, preferences, pubkey).catch((err) => {
            Services.prompt.alert(null, 'Debug log submission error', `${err}`); // eslint-disable-line @typescript-eslint/restrict-template-expressions
        });
    }
    async sendAsync(plugin, preferences, pubkey = '') {
        await Zotero.Schema.schemaUpdatePromise;
        const bundler = new Bundler(pubkey);
        let log = [
            await this.info(preferences),
            Zotero.getErrors(true).join('\n\n'),
            Zotero.Debug.getConsoleViewerOutput().slice(-250000).join('\n'), // eslint-disable-line no-magic-numbers
        ].filter((txt) => txt).join('\n\n').trim();
        await bundler.add('debug.txt', log);
        let rdf = await this.rdf();
        if (rdf)
            await bundler.add('items.rdf', rdf, true);
        try {
            const response = await fetch('https://0x0.st', {
                method: 'POST',
                body: bundler.formData(),
                headers: {
                    'User-Agent': `Zotero-plugin/${pkg.version}`,
                },
            });
            const body = await response.text();
            const id = body.match(/https:\/\/0x0.st\/([A-Z0-9]+)\.zip/i);
            if (!id)
                throw new Error(body);
            Services.prompt.alert(null, `Debug log ID for ${plugin}`, bundler.id(`0x0-${id[1]}`));
        }
        catch (err) {
            Services.prompt.alert(null, `Could not post debug log for ${plugin}`, err.message);
        }
    }
    preferences(preferences) {
        const prefs = {};
        const names = [];
        for (let pref of preferences) {
            if (pref[0] === ':') {
                pref = pref.substring(1);
            }
            else if (!pref.startsWith(zotero_prefs_root)) {
                pref = zotero_prefs_root + pref;
            }
            if (pref.endsWith('.')) {
                const childkeys = Services.prefs.getBranch(pref).getChildList('', {});
                for (const key of childkeys) {
                    names.push(pref + key);
                }
            }
            else {
                names.push(pref);
            }
        }
        for (const pref of names.sort()) {
            prefs[pref] = Zotero.Prefs.get(pref, true);
        }
        return prefs;
    }
    // general state of Zotero
    async info(preferences) {
        let info = '';
        // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-assignment
        const appInfo = Components.classes['@mozilla.org/xre/app-info;1'].getService(Components.interfaces.nsIXULAppInfo);
        info += `Application: ${appInfo.name} ${appInfo.version} ${Zotero.locale}\n`;
        const platform = ['Win', 'Mac', 'Linux'].find(p => Zotero[`is${p}`]) || 'Unknown';
        const arch = Zotero.oscpu || Zotero.arch;
        info += `Platform: ${platform} ${arch}\n`;
        const addons = await Zotero.getInstalledExtensions();
        if (addons.length) {
            info += 'Addons:\n' + addons.map((addon) => `  ${addon}\n`).join(''); // eslint-disable-line prefer-template
        }
        info += `Debug logging on at Zotero start: ${this.debugEnabledAtStart}\n`;
        info += `Debug logging on at log submit: ${Zotero.Prefs.get('debug.store') || Zotero.Debug.enabled}\n`;
        for (const [pref, value] of Object.entries(this.preferences(preferences))) {
            info += `${pref} = ${JSON.stringify(value)}\n`;
        }
        return info;
    }
    rdf() {
        return new Promise((resolve, reject) => {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-assignment
            const items = Zotero.getActiveZoteroPane().getSelectedItems();
            if (items.length === 0)
                return resolve('');
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call
            const translation = new Zotero.Translate.Export();
            translation.setItems(items);
            translation.setTranslator('14763d24-8ba0-45df-8f52-b8d1108e7ac9'); // rdf
            translation.setHandler('done', (obj, success) => {
                if (success) {
                    resolve(obj ? obj.string : undefined);
                }
                else {
                    reject(new Error('translation failed'));
                }
            });
            translation.translate(); // eslint-disable-line @typescript-eslint/no-unsafe-call
        });
    }
    arrayBufferToBase64(buffer) {
        let binary = '';
        const bytes = new Uint8Array(buffer);
        const len = bytes.byteLength;
        for (let i = 0; i < len; i++) {
            binary += String.fromCharCode(bytes[i]);
        }
        return btoa(binary);
    }
    base64ToArrayBuffer(base64) {
        const binaryString = atob(base64);
        const len = binaryString.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binaryString.charCodeAt(i);
        }
        return bytes.buffer;
    }
}
exports.DebugLog = new DebugLogSender();
